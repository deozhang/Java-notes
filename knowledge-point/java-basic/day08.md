回顾：
构造方法：
语法：
   public 类名（）{
	
	
	}
作用：初始化成员变量（实例化对象）
创建对象，就是调用与之对应的构造方法，实例化对象
构造方法也支持方法的重载（一个类中，方法名相同参数列表不同，与返回值无关）

内存管理:
jvm把计算内存分为：
栈：局部变量，引用变量名，方法的参数值
堆：对象，成员变量
方法区：方法，类的信息（静态区，非静态区）

变量：
局部变量:方法内，没有默认值，使用之前必须初始化，方法调用完失效--栈
成员变量：类中，方法外，有默认值，可以不初始化，与对象在一起，对象回收，成员变量失效--堆

面向对象的三大特性：
封装：
-Javabean如何封装，遵循规则：
-好处：

继承：
-主要作用：提升代码的重用率，是多态的前提
-让类与类之间产生强耦合的关系
-关键：extends
-被继承的称为父类，继承的类称为子类，子类只能继承父类中非私有的属性
-java只支持单继承，不支持多继承，但是支持多层继承（继承体系--继承具有传递性）

-this和super：this指代当前对象     super当前对象父类的引用
-父类的构造方法，子类只能调用，不能继承，而且子类所有构造方法中第一句默认调用父类的无参构造
方法（父类中，即使不使用无参构造方法，也要讲无参 构造方法写出，防止编译报错 ）

-super用法：

成员变量的继承：

-父类和子类出现相同的成员变量：就近原则（用谁创建对象，就调用那个类中成员变量）

-父类和子类出现不同的成员变量：直接继承（非私有）


今天：

方法的继承：

如果子类中出现与父类中一样的方法，该怎么做？

方法的重写：
概念：子父类中出现相同的方法（方法名，参数列表，返回值类型）--叫做方法的重写
方法重写的应用：当子类需要使用父类的功能，而子类有自己特有的功能主体（与父类不同），可以
重写父类的方法（重写的是方法体）

重写注意的事项：
1.父类当中私有的方法不能重写（因为私有的方法，根本不能被子类继承）
2.子类重写父类的方法时，子类方法的权限要大于等于父类的方法权限（建议统一）--语法现象
3.父类中的静态方法，子类也必须通过静态方法重写

方法的重写和方法重载的区别：

overload：重载
	发生在一个类，方法名相同，参数列表不同，与返回值无关	
override：重写
	发生在两个类,一般是子父类，子类出现与父类中方法相同（方法名，参数列表），方法体不同，		与返回值有关（子父类中返回值一致）
多态：
默认父类要大于子类
泛化：把多个类型中公有的属性集合到一个类中，形成一个新类，这个过程叫做泛化（小--大）
 向上造型--父类引用指向子类的对象
	Father f1=new Son();
	如果子类重写了父类中的方法，通过这种方式调用的是子类中已经重写的父类方法
	Animal   a=new Dog();//
	int a=45;


特化：由一个类衍生出多个子类，这个过程叫做特化（大--小）
    
	关键字： instanceof  



1.定义一个人类，包括属性：姓名，性别，年龄，国籍，包括方法吃饭，睡觉，工作
	1.根据人类，派生一个学生类，增加属性：单位，学号：重写工作的方法（学习）
	2.根据学生类派生一个学生干部类，增加属性：职务，增加方法：开会
	3.根据人类派生一个工人类，增加属性：单位，工龄；重写工作方法
	4.编写一个主函数，测试上述这三种类的具体人物方法和属性


2.class Super{
	public void f(){
	syso("super.f()");
	}
}

class Sub extends Super{
	public void f(){
	syso("sub.f()");	
 	}
}
class Goo{
	public void g(Super obj){
	syso("g(Super)");
	obj.f();
	}
	public void g(Sub obj){
	syso("(g(Sub)")；
	obj.f();
	}
}
main(){
	Super obj=new Sub();
	Goo goo=new Goo();
         goo.g(obj);
}

输出结果:?
练习：
	1.创建Aoo类，包含show（），输出111
	2.创建Boo类，继承Aoo，包含show（），输出222
	3.创建Coo类，包含:
	  t(Aoo o){输出 333 o.show();}
	  t(Boo o){输出 444 o.show();}
	测试类的main方法中：
 Aoo o =new Boo();
 Coo c=new Coo();
  c.t(o);-----问输出结果？
































